## For more information about the format of the policy.conf file and the various
## conditions and actions that are supported by the PTS, use "man policy.conf"
## or refer to the Policy Guide.
##
## Do not edit this file.  Copy policy.conf.sample to policy.conf and 
## edit policy.conf.
##
## These examples assume that there are two network classes defined in
## subnets.txt named "internal" and "external".

# subscriber_classes "internal"
################################################################################
## STATS COLLECTION
################################################################################

## collect traffic stats for ports and network classes
if true then count and count demographic

## collect detailed subscriber stats for subscribers that have the
## "substats" attribute set to "detail" and basic subscriber stats for everybody
## else
# attribute "substats" values "detail" "basic"
# if expr(Flow.Subscriber.Attribute.substats = "detail") then \
#     count subscriber protocol
# if true then count subscriber basic

## collect basic subscriber stats for everyone and detailed subscriber stats for
## top talkers
# include "/usr/local/sandvine/etc/policy.conf.top_talker"

################################################################################
## MEASUREMENTS
################################################################################

## measure the number of encrypted bittorrent unidirectional uploads
# measurement "EncryptedBittorrentUp" connections where protocol \
#     "bittorrent_encrypted" and transfer uni and receiver class "external"

## measure the upload bitrate of unidirectional edonkey upload flows
# measurement "EdonkeyUniUp" bitrate to receiver where protocol "edonkey" and \
#     transfer uni and receiver class "external"

## measure the upload bitrate of traffic minus some P2P protocols
## this is an example of how to use the source/destination node qualifier to
## indicate direction
# measurement "NonP2pUpload" bitrate where \
#     not(expr(Flow.IsApplicationProtocol( \
#             "gnutella", \
#             "fasttrack", \
#             "edonkey", \
#             "bittorrent", \
#             "winmx", \
#             "directconnect" \
#     ))) and source class "internal"

## measure the number of hosts that have the "spammer" attribute set to "true"
# attribute "spammer" values "true" "false"
# measurement "Spammers" hosts where \
#     expr(Flow.Subscriber.Attribute.spammer = "true")

## measure the number of flows that are being shaped
# measurement "ShapedConnections" connections where expr(Flow.IsShaped)

################################################################################
## SESSION MANAGEMENT
################################################################################

## allow 100 gnutella uploads
# limiter "GnutellaUploads" 100 connections where protocol "gnutella" and \
#     receiver class "external" and expr(not(Flow.IsReset))
# if protocol "gnutella" and receiver class "external" and \
#     expr(Limiter.GnutellaUploads.Limit) then tcp_reset

## allow 2 gnutella uploads per subscriber
# limiter "GnutellaUploadsPerSub" 2 connections where protocol "gnutella" and \
#     receiver class "external" and expr(not(Flow.IsReset)) unique by subscriber
# if protocol "gnutella" and receiver class "external" and \
#     expr(Limiter.GnutellaUploads.Limit) then tcp_reset

## limit the Edonkey upload rate to 100Mbps by managing unidirectional uploads
## and bidirectional flows
# if protocol "edonkey" then reevaluate flow on DataTransferDirection
# limiter "EdonkeyUpload" 100Mbps where protocol "edonkey" and \
#     source class "internal" priority "new" priority "existing"
# PolicyGroup protocol "edonkey" {
#     if transfer unknown then continue
#     PolicyGroup (transfer uni and receiver class "external") or transfer bi {
#         if expr(Flow.IsReevaluatingPolicy and \
#             Limiter.EdonkeyUpload.Existing.Limit) then tcp_reset
#         if expr(not(Flow.IsReevaluatingPolicy) and \
#             Limiter.EdonkeyUpload.New.Limit) then tcp_reset
#     }
# }

## limit ares, gnutella, edonkey and bittorrent upload rate to 200Mbps between
## 13:00 and 03:00
# if expr(Flow.IsApplicationProtocol("edonkey", "bittorrent")) then \
#     reevaluate flow on DataTransferDirection
# limiter "P2PUpload" 200Mbps where expr(Flow.IsApplicationProtocol("ares", \
#             "gnutella", "edonkey", "bittorrent")) and source class "internal" \
#     priority "AresNew" priority "AresExisting" \
#     priority "GnutellaNew" priority "GnutellaExisting" \
#     priority "EdonkeyNew" priority "EdonkeyExisting" \
#     priority "BittorrentNew" priority "BittorrentExisting"
# PolicyGroup time hours 1300-0300 {
#     PolicyGroup protocol "ares" {
#         PolicyGroup receiver class "external" {
#             if expr(Flow.IsReevaluatingPolicy and \
#                 Limiter.P2PUpload.AresExisting.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                 Limiter.P2PUpload.AresNew.Limit) then tcp_reset
#         }
#     }
#     PolicyGroup protocol "gnutella" {
#         PolicyGroup receiver class "external" {
#             if expr(Flow.IsReevaluatingPolicy and \
#                 Limiter.P2PUpload.GnutellaExisting.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                 Limiter.P2PUpload.GnutellaNew.Limit) then tcp_reset
#         }
#     }
#     PolicyGroup protocol "edonkey" {
#         if transfer unknown then continue
#         PolicyGroup (transfer uni and receiver class "external") or \
#                      transfer bi {
#             if expr(Flow.IsReevaluatingPolicy and \
#                 Limiter.P2PUpload.EdonkeyExisting.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                 Limiter.P2PUpload.EdonkeyNew.Limit) then tcp_reset
#         }
#     }
#     PolicyGroup protocol "bittorrent" {
#         if transfer unknown then continue
#         PolicyGroup (transfer uni and receiver class "external") {
#             if expr(Flow.IsReevaluatingPolicy and \
#                 Limiter.P2PUpload.BittorrentExisting.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                 Limiter.P2PUpload.BittorrentNew.Limit) then tcp_reset
#         }
#     }
# }

## Maintain total upload bandwidth to 95% of capacity (1Gpbs in this
## example).  Prioritize bittorrent and edonkey above other peer-to-peer
## protocols (i.e. limit them only if required to acheive target rate).
# limiter "AllUpload" 950Mbps where source class "internal" \
#     priority "Priority1New" priority "Priority1Existing" \
#     priority "Priority2New" priority "Priority2Existing" \
#     priority "Priority3New" priority "Priority3Existing" \
#     priority "Priority4New" priority "Priority4Existing" \
#
# if expr(Flow.IsApplicationProtocol("edonkey", "bittorrent")) then \
#     reevaluate flow on DataTransferDirection
# 
# PolicyGroup {
#     PolicyGroup expr(Flow.IsApplicationPrtocol("ares", "gnutella", "winmx")) {
#         PolicyGroup receiver class "external" {
#             if expr(Flow.IsReevaluatingPolicy and \
#                     Limiter.AllUpload.Priority1Existing.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                     Limiter.AllUpload.Priority1New.Limit) then tcp_reset
#         }
#     }
#     PolicyGroup protocol "edonkey" {
#         PolicyGroup receiver class "external" {
#             if expr(Flow.IsReevaluatingPolicy and \
#                     Limiter.AllUpload.Priority2Existing.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                     Limiter.AllUpload.Priority2New.Limit) then tcp_reset
#         }
#     }
#     PolicyGroup protocol "bittorrent" {
#         PolicyGroup transfer uni and receiver class "external" {
#             if expr(Flow.IsReevaluatingPolicy and \
#                     Limiter.AllUpload.Priority3Existing.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                     Limiter.AllUpload.Priority3New.Limit) then tcp_reset
#         }
#     PolicyGroup receiver class "external" {
#             if expr(Flow.IsReevaluatingPolicy and \
#                     Limiter.AllUpload.Priority4Existing.Limit) then tcp_reset
#             if expr(not(Flow.IsReevaluatingPolicy) and \
#                     Limiter.AllUpload.Priority4New.Limit) then tcp_reset
#         }
#     }
# }


################################################################################
## SHAPING
################################################################################

## aggregate shaper for gnutella download
# shaper "GnutellaDown" 20Mbps
# if protocol "gnutella" then shape to subscriber shaper "GnutellaDown"

## shared shaper for gnutella download - like aggregate but more fair and more
## expensive in terms of performance
# shaper "GnutellaDownFair" 20Mbps
# if protocol "gnutella" then shape to subscriber shaper "GnutellaDownFair" \
#     shared by (Flow.Subscriber.IpAddress)

## shared shaper for gnutella download with virtual queues - much less
## expensive than regular shared-by shaping but the output rate per
## instance isn't quite as smooth
# shaper "GnutellaDownFairVirtual" 20Mbps priority "Normal" algorithm virtual
# if protocol "gnutella" then shape to subscriber \
#     shaper "GnutellaDownFairVirtual" priority "Normal" \
#     shared by (Flow.Subscriber.IpAddress)

## shape gnutella download for each subscriber to 30kbps
# shaper "GnutellaDownPerSub" 30kbps
# if protocol "gnutella" then shape to subscriber shaper "GnutellaDownPerSub" \
#     unique by (Flow.Subscriber.IpAddress)

## police gnutella download for each subscriber to 30kbps - much less
## expensive than regular unique by shaping
# shaper "GnutellaDownPerSubPolice" 30kbps priority "Normal" algorithm police
# if protocol "gnutella" then shape to subscriber \
#     shaper "GnutellaDownPerSubPolice" priority "Normal" \
#     unique by (Flow.Subscriber.IpAddress)

## shape gnutella, edonkey and bittorrent to 200Mbps
## the queues are weighted such that gnutella and ares are guaranteed 20Mbps,
## edonkey is guaranteed 80Mpbs and bittorrent is guaranteed 100Mbps
# shaper "P2PDown" 200Mbps \
#     priority "Normal" algorithm shape \
#         channel "GnutellaAndAres" weight 1 \
#         channel "Edonkey" weight 4 \
#         channel "Bittorrent" weight 5
# PolicyGroup {
#     if expr(Flow.IsApplicationProtocol("gnutella", "ares")) then shape to subscriber \
#         shaper "P2PDown" priority "Normal" channel "GnutellaAndAres"
#     if protocol "edonkey" then shape to subscriber \
#         shaper "P2PDown" priority "Normal" channel "Edonkey"
#     if protocol "bittorrent" then shape to subscriber \
#         shaper "P2PDown" priority "Normal" channel "Bittorrent"
# }

## For each sub, prioritize skype traffic above all other traffic. In
## general, the total traffic will not exceed 20kbps, but if skype
## alone has more than 20kbps of demand, it will be shaped to 30kbps
## and all other traffic will be completely dropped. Half of the
## non-skype traffic rate is allocated to web traffic.
# shaper "User" 30kbps \
#     priority "High" algorithm police \
#     priority "Low" algorithm shape max_rate 20kbps \
#         channel "Web" weight 1 \
#         channel "Other" weight 1
# PolicyGroup {
#     if protocol "skype" then shape to subscriber \
#         shaper "User" priority "High" unique by subscriber
#     if protocol "http" then shape to subscriber \
#         shaper "User" priority "Low" channel "Web" unique by subscriber
#     if true then shape to subscriber \
#         shaper "User" priority "Low" channel "Other" unique by subscriber
# }

## implement "bronze", "silver" and "gold" service tiers, with special handling
## for a "turbo button"
# attribute "turbo_button" values "true" "false"
# attribute "service_tier" values "gold" "silver" "bronze" 
# shaper "slow_down" 32Kbps 
# shaper "slow_up"   32Kbps
# shaper "mid_down"  200Kbps 
# shaper "fast_down" 512Kbps 
# shaper "fast_up"   256Kbps
# PolicyGroup {
#     if expr(Flow.Subscriber.Attribute.turbo_button = "true" or \
#             Flow.Subscriber.Attribute.service_tier = "gold") then \
#         shape to subscriber shaper "fast_down" \
#             unique by (Flow.Subscriber.IpAddress) and \
#         shape to internet shaper "fast_up" \
#             unique by (Flow.Subscriber.IpAddress)
#     if expr(Flow.Subscriber.Attribute.service_tier = "silver") then \
#         shape to subscriber shaper "mid_down" \
#             unique by (Flow.Subscriber.IpAddress) and \
#         shape to internet shaper "mid_up" \
#             unique by (Flow.Subscriber.IpAddress)
#     if expr(Flow.Subscriber.Attribute.service_tier = "bronze") then \
#         shape to subscriber shaper "slow_down" \
#             unique by (Flow.Subscriber.IpAddress) and \
#         shape to internet shaper "slow_up" \
#             unique by (Flow.Subscriber.IpAddress)
# }

################################################################################
## TEEING
################################################################################

## tee all gnutella traffic by rewriting the destination ethernet address
# destination "Tee" tee next_hop 1.2.3.4 payload ether
# if protocol "gnutella" then \
#     tee from client destination "Tee1" and \
#     tee from server destination "Tee1"

## tee all traffic from subscribers with the "tee" attribute set to "true"
## encapsulate with IP, UDP and binary headers
## put a timestamp and the subscriber ID in the binary header.
# attribute "tee" type boolean
# destination "Tee" tee payload packet \
#    ip dst_addr 1.2.3.4 \
#    udp dst_port 1234 \
#    binary "WI" Now Subscriber.Id
# if expr(Flow.Subscriber.Attribute.tee) then tee from subscriber \
#     destination "Tee"

################################################################################
## DIVERTING
################################################################################
## Sample divert policy can be found in policy.conf.divert.sample
#
################################################################################
## CAPTURE TO FILE
################################################################################

## capture all TCP traffic with server port 62311.
# destination "File" file "Port62311" file_size 20Mbytes file_count 10 \
#     overwrite true
# if layer4protocol TCP and server tcp_port 62311 then \
#     tee from client destination "File" and \
#     tee from server destination "File"

################################################################################
## CAPTIVE PORTAL
################################################################################

## send "infected" subscribers to a captive portal
# attribute "infected" type boolean
# if protocol "http" and expr(Flow.Subscriber.Attribute.infected) then \
#     captive_portal "http://www.isp.com/infected/help.htm" \
#     cycle 120sec interferences 2

################################################################################
## USER-DEFINED PROTOCOLS
################################################################################

# protocol user1 re TCP "yahoo.com"
# protocol user2 re UDP "\`\0x10.\'"

################################################################################
## SUBSCRIBER BEHAVIOURAL POLICY
################################################################################

# package bandwidth_use_detection\
#     max_download=4Mbytes\
#     max_upload=3Mbytes\
#     time_interval="5minutes"\ 
#     protocols=p2p

# package bandwidth_use_management \
#     mode="limiting" \
#     min_connections=0 \
#     max_connections=12 \
#     protocols="p2p=1"

